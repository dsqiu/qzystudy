Command类，用来声明执行操作的接口

ConcreteCommand,将一个接收者对象绑定于一个操作，调用接收者相应的操作，以实现Execute

Invoker类，要求该命令执行这个请求

Receiver类，知道如何实施与执行一个与请求相关的操作，任何类都可能作为一个接收者。

Command模式通过将请求封装到一个对象Command中，并将请求的接收者存放到具体的ConcreteCommand类中，从而实现调用操作的对象和操作的具体实现者之间的解耦。

Command模式结构图中，将请求的接收者（处理者）放到Command的具体子类ConcreteCommand中，当请求到来时(Invoker发出Invoke消息激活Command对象)，ConcreteCommand将处理请求交给Receiver对象进行处理。

命令模式的优点：
1，它能较容易地设计一个命令队列；
2，在需要的情况下，可以较容易地将命令记入日志；
3，允许接收请求的一方决定是否要否决请求。
4，可以容易地实现对请求的撤销和重做；
5，由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。

命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开。

Command模式关键就是讲一个请求封装到一个类中(Command），再提供处理对象（Receiver），最后Command命令由Invoker激活。另外，我们可以将请求接收者的处理抽象出来作为参数传给Command对象，实际也就是回调的机制来实现这一点。也就是讲处理操作方法地址通过参数传递给Command对象，Command对象在适当的时候再调用该函数。

Command模式将调用操作的对象和知道如何实现该操作的对象解耦，在上面Command的结构图中,Invoker对象根本就不知道具体的是哪个对象在处理Execute操作（当然要知道是Command类别的对象）。
在Command要增加新的处理操作对象很容易，我们可以通过创建新的继承自Command的子类来实现这一点。
Command模式可以和Memento模式结合起来，支持取消的操作。
